{"title":"ES6-async","date":"2019-10-06T16:00:00.000Z","link":"2019/10/07/ES6-Docs/ES6-async","tags":["ES6","ES6-async"],"categories":["ES6"],"updated":"2019-10-07T09:03:34.000Z","content":"<h1 id=\"async-函数\">async 函数<a href=\"2019/10/07/ES6-Docs/ES6-async#async-函数\"></a></h1><h2 id=\"含义\">含义<a href=\"2019/10/07/ES6-Docs/ES6-async#含义\"></a></h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>\n<p>（1）内置执行器。</p>\n<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asyncReadFile();</span><br></pre></td></tr></table></div></figure>\n\n<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>\n<p>（2）更好的语义。</p>\n<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>\n<p>（3）更广的适用性。</p>\n<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>\n<p>（4）返回值是 Promise。</p>\n<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>\n<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>\n<h2 id=\"基本用法\">基本用法<a href=\"2019/10/07/ES6-Docs/ES6-async#基本用法\"></a></h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStockPriceByName</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> symbol = <span class=\"keyword\">await</span> getStockSymbol(name);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stockPrice = <span class=\"keyword\">await</span> getStockPrice(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockPrice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getStockPriceByName(<span class=\"string\">'goog'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p>\n<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>async 函数有多种使用形式。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"keyword\">async</span> foo() &#123;&#125; &#125;;</span><br><span class=\"line\">obj.foo().then(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class 的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Storage</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cachePromise = caches.open(<span class=\"string\">'avatars'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">async</span> getAvatar(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cache = <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.cachePromise;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.match(<span class=\"string\">`/avatars/<span class=\"subst\">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage = <span class=\"keyword\">new</span> Storage();</span><br><span class=\"line\">storage.getAvatar(<span class=\"string\">'jake'</span>).then(…);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"语法\">语法<a href=\"2019/10/07/ES6-Docs/ES6-async#语法\"></a></h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>\n<h3 id=\"返回-Promise-对象\">返回 Promise 对象<a href=\"2019/10/07/ES6-Docs/ES6-async#返回-Promise-对象\"></a></h3><p><code>async</code>函数返回一个 Promise 对象。</p>\n<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// \"hello world\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>\n<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(</span><br><span class=\"line\">  v =&gt; <span class=\"built_in\">console</span>.log(v),</span><br><span class=\"line\">  e =&gt; <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"Promise-对象的状态变化\">Promise 对象的状态变化<a href=\"2019/10/07/ES6-Docs/ES6-async#Promise-对象的状态变化\"></a></h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTitle</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.text();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.match(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getTitle(<span class=\"string\">'https://tc39.github.io/ecma262/'</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// \"ECMAScript 2017 Language Specification\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<h3 id=\"await-命令\">await 命令<a href=\"2019/10/07/ES6-Docs/ES6-async#await-命令\"></a></h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等同于</span></span><br><span class=\"line\">  <span class=\"comment\">// return 123;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p>\n<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(timeout) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.timeout = timeout;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  then(resolve, reject) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    setTimeout(</span><br><span class=\"line\">      () =&gt; resolve(<span class=\"built_in\">Date</span>.now() - startTime),</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.timeout</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sleepTime = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> Sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(sleepTime);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// 1000</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p>\n<p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">interval</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, interval);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">one2FiveInAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">one2FiveInAsync();</span><br></pre></td></tr></table></div></figure>\n\n<p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></div></figure>\n\n<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></div></figure>\n\n<p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"错误处理\">错误处理<a href=\"2019/10/07/ES6-Docs/ES6-async#错误处理\"></a></h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// Error：出错了</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>\n<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span>(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val1 = <span class=\"keyword\">await</span> firstStep();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val2 = <span class=\"keyword\">await</span> secondStep(val1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val3 = <span class=\"keyword\">await</span> thirdStep(val1, val2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Final: '</span>, val3);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">'superagent'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> NUM_RETRIES = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> superagent.get(<span class=\"string\">'http://google.com/this-throws-an-error'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(err) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>\n<h3 id=\"使用注意点\">使用注意点<a href=\"2019/10/07/ES6-Docs/ES6-async#使用注意点\"></a></h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> somethingThatReturnsAPromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> somethingThatReturnsAPromise()</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> getBar();</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([getFoo(), getBar()]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = getBar();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123; <span class=\"comment\">//这里不需要 async</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可能得到错误结果</span></span><br><span class=\"line\">  docs.forEach(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.push(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>第四点，async 函数可以保留运行堆栈。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  b().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> c());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p>\n<p>现在将这个例子改成<code>async</code>函数。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> b();</span><br><span class=\"line\">  c();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>\n<h2 id=\"async-函数的实现原理\">async 函数的实现原理<a href=\"2019/10/07/ES6-Docs/ES6-async#async-函数的实现原理\"></a></h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>\n<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spawn</span>(<span class=\"params\">genF</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gen = genF();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">nextF</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> next;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        next = nextF();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(next.done) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolve(next.value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve(next.value).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">        step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.next(v); &#125;);</span><br><span class=\"line\">      &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.throw(e); &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.next(<span class=\"literal\">undefined</span>); &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"与其他异步处理方法的比较\">与其他异步处理方法的比较<a href=\"2019/10/07/ES6-Docs/ES6-async#与其他异步处理方法的比较\"></a></h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>\n<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>\n<p>首先是 Promise 的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsPromise</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 变量ret用来保存上一个动画的返回值</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 新建一个空的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 使用then方法，添加所有动画</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">    p = p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">      ret = val;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> anim(elem);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> p.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>\n<p>接着是 Generator 函数的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsGenerator</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">        ret = <span class=\"keyword\">yield</span> anim(elem);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p>\n<p>最后是 async 函数的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsAsync</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">      ret = <span class=\"keyword\">await</span> anim(elem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p>\n<h2 id=\"实例：按顺序完成异步操作\">实例：按顺序完成异步操作<a href=\"2019/10/07/ES6-Docs/ES6-async#实例：按顺序完成异步操作\"></a></h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>\n<p>Promise 的写法如下。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程读取所有URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"function\"><span class=\"params\">url</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(url).then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.text());</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  textPromises.reduce(<span class=\"function\">(<span class=\"params\">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> textPromise)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">text</span> =&gt;</span> <span class=\"built_in\">console</span>.log(text));</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>\n<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> url <span class=\"keyword\">of</span> urls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> response.text());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p>\n<h2 id=\"顶层-await\">顶层 await<a href=\"2019/10/07/ES6-Docs/ES6-async#顶层-await\"></a></h2><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(<span class=\"string\">'https://api.example.com'</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p>\n<p>目前，有一个<a href=\"https://github.com/tc39/proposal-top-level-await\" target=\"_blank\" rel=\"noopener\">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  output = someProcess(dynamic.default, data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main();</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p>\n<p>上面的代码也可以写成立即执行函数的形式。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output;</span><br><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  output = someProcess(dynamic.default, data);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>下面是加载这个模块的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./awaiting.js\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outputPlusValue</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"keyword\">return</span> output + value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>));</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>), <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p>\n<p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  output = someProcess(dynamic.default, data);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p>\n<p>下面是加载这个模块的新的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> promise, &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./awaiting.js\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outputPlusValue</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"keyword\">return</span> output + value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>));</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p>\n<p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p>\n<p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\"><span class=\"keyword\">const</span> data = fetch(url);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> output = someProcess((<span class=\"keyword\">await</span> dynamic).default, <span class=\"keyword\">await</span> data);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p>\n<p>加载这个模块的写法如下。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./awaiting.js\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outputPlusValue</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"keyword\">return</span> output + value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>));</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>), <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p>\n<p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p>\n<p>下面是顶层<code>await</code>的一些使用场景。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import() 方法加载</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> strings = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">`/i18n/<span class=\"subst\">$&#123;navigator.language&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数据库操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connection = <span class=\"keyword\">await</span> dbConnector();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 依赖回滚</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> jQuery;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  jQuery = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'https://cdn-a.com/jQuery'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">  jQuery = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'https://cdn-b.com/jQuery'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"X1\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> setTimeout(r, <span class=\"number\">1000</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"X2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// y.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Y\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// z.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"./x.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"./y.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Z\"</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p>\n<p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>\n","prev":{"title":"ES6-array","link":"2019/10/07/ES6-Docs/ES6-array"},"next":{"title":"ES6-class","link":"2019/10/07/ES6-Docs/ES6-class"},"plink":"https://guo213.github.io/2019/10/07/ES6-Docs/ES6-async/","toc":[{"title":"async 函数","id":"async-函数","index":"1","children":[{"title":"含义","id":"含义","index":"1.1"},{"title":"基本用法","id":"基本用法","index":"1.2"},{"title":"语法","id":"语法","index":"1.3","children":[{"title":"返回 Promise 对象","id":"返回-Promise-对象","index":"1.3.1"},{"title":"Promise 对象的状态变化","id":"Promise-对象的状态变化","index":"1.3.2"},{"title":"await 命令","id":"await-命令","index":"1.3.3"},{"title":"错误处理","id":"错误处理","index":"1.3.4"},{"title":"使用注意点","id":"使用注意点","index":"1.3.5"}]},{"title":"async 函数的实现原理","id":"async-函数的实现原理","index":"1.4"},{"title":"与其他异步处理方法的比较","id":"与其他异步处理方法的比较","index":"1.5"},{"title":"实例：按顺序完成异步操作","id":"实例：按顺序完成异步操作","index":"1.6"},{"title":"顶层 await","id":"顶层-await","index":"1.7"}]}]}