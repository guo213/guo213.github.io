{"title":"ES6-symbol","date":"2019-10-06T16:00:00.000Z","link":"2019/10/07/ES6-Docs/ES6-symbol","tags":["ES6","ES6-symbol"],"categories":["ES6"],"updated":"2019-10-07T09:03:34.000Z","content":"<h1 id=\"Symbol\">Symbol<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol\"></a></h1><h2 id=\"概述\">概述<a href=\"2019/10/07/ES6-Docs/ES6-symbol#概述\"></a></h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\n<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>\n<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s</span><br><span class=\"line\"><span class=\"comment\">// \"symbol\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p>\n<p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>\n<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">s1 <span class=\"comment\">// Symbol(foo)</span></span><br><span class=\"line\">s2 <span class=\"comment\">// Symbol(bar)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s1.toString() <span class=\"comment\">// \"Symbol(foo)\"</span></span><br><span class=\"line\">s2.toString() <span class=\"comment\">// \"Symbol(bar)\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>\n<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'abc'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>(obj);</span><br><span class=\"line\">sym <span class=\"comment\">// Symbol(abc)</span></span><br></pre></td></tr></table></div></figure>\n\n<p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有参数的情况</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有参数的情况</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// false</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>\n<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'My symbol'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"your symbol is \"</span> + sym</span><br><span class=\"line\"><span class=\"comment\">// TypeError: can't convert symbol to string</span></span><br><span class=\"line\"><span class=\"string\">`your symbol is <span class=\"subst\">$&#123;sym&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></div></figure>\n\n<p>但是，Symbol 值可以显式转为字符串。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'My symbol'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span>(sym) <span class=\"comment\">// 'Symbol(My symbol)'</span></span><br><span class=\"line\">sym.toString() <span class=\"comment\">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></div></figure>\n\n<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(sym) <span class=\"comment\">// true</span></span><br><span class=\"line\">!sym  <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (sym) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(sym) <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">sym + <span class=\"number\">2</span> <span class=\"comment\">// TypeError</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"Symbol-prototype-description\">Symbol.prototype.description<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-prototype-description\"></a></h2><p>创建 Symbol 的时候，可以添加一个描述。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p>\n<p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span>(sym) <span class=\"comment\">// \"Symbol(foo)\"</span></span><br><span class=\"line\">sym.toString() <span class=\"comment\">// \"Symbol(foo)\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面的用法不是很方便。<a href=\"https://github.com/tc39/proposal-Symbol-description\" target=\"_blank\" rel=\"noopener\">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sym.description <span class=\"comment\">// \"foo\"</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"作为属性名的-Symbol\">作为属性名的 Symbol<a href=\"2019/10/07/ES6-Docs/ES6-symbol#作为属性名的-Symbol\"></a></h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;&#125;;</span><br><span class=\"line\">a[mySymbol] = <span class=\"string\">'Hello!'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">  [mySymbol]: <span class=\"string\">'Hello!'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a, mySymbol, &#123; <span class=\"attr\">value</span>: <span class=\"string\">'Hello!'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上写法都得到同样结果</span></span><br><span class=\"line\">a[mySymbol] <span class=\"comment\">// \"Hello!\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p>\n<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.mySymbol = <span class=\"string\">'Hello!'</span>;</span><br><span class=\"line\">a[mySymbol] <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a[<span class=\"string\">'mySymbol'</span>] <span class=\"comment\">// \"Hello!\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>\n<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj[s](<span class=\"number\">123</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>\n<p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s](arg) &#123; ... &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">log.levels = &#123;</span><br><span class=\"line\">  DEBUG: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'debug'</span>),</span><br><span class=\"line\">  INFO: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'info'</span>),</span><br><span class=\"line\">  WARN: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'warn'</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(log.levels.DEBUG, <span class=\"string\">'debug message'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(log.levels.INFO, <span class=\"string\">'info message'</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>下面是另外一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> COLOR_RED    = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> COLOR_GREEN  = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getComplement</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (color) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COLOR_RED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> COLOR_GREEN;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COLOR_GREEN:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> COLOR_RED;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Undefined color'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p>\n<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>\n<h2 id=\"实例：消除魔术字符串\">实例：消除魔术字符串<a href=\"2019/10/07/ES6-Docs/ES6-symbol#实例：消除魔术字符串\"></a></h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArea</span>(<span class=\"params\">shape, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> area = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Triangle'</span>: <span class=\"comment\">// 魔术字符串</span></span><br><span class=\"line\">      area = <span class=\"number\">.5</span> * options.width * options.height;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* ... more code ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> area;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getArea(<span class=\"string\">'Triangle'</span>, &#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">height</span>: <span class=\"number\">100</span> &#125;); <span class=\"comment\">// 魔术字符串</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>\n<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shapeType = &#123;</span><br><span class=\"line\">  triangle: <span class=\"string\">'Triangle'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArea</span>(<span class=\"params\">shape, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> area = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> shapeType.triangle:</span><br><span class=\"line\">      area = <span class=\"number\">.5</span> * options.width * options.height;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> area;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getArea(shapeType.triangle, &#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">height</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p>\n<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shapeType = &#123;</span><br><span class=\"line\">  triangle: <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p>\n<h2 id=\"属性名的遍历\">属性名的遍历<a href=\"2019/10/07/ES6-Docs/ES6-symbol#属性名的遍历\"></a></h2><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>\n<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'b'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">obj[a] = <span class=\"string\">'Hello'</span>;</span><br><span class=\"line\">obj[b] = <span class=\"string\">'World'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">objectSymbols</span><br><span class=\"line\"><span class=\"comment\">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></div></figure>\n\n<p>下面是另一个例子，<code>Object.getOwnPropertySymbols</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, foo, &#123;</span><br><span class=\"line\">  value: <span class=\"string\">\"foobar\"</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 无输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(obj)</span><br><span class=\"line\"><span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertySymbols(obj)</span><br><span class=\"line\"><span class=\"comment\">// [Symbol(foo)]</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，使用<code>Object.getOwnPropertyNames</code>方法得不到<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法。</p>\n<p>另一个新的 API，<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>(<span class=\"string\">'my_key'</span>)]: <span class=\"number\">1</span>,</span><br><span class=\"line\">  enum: <span class=\"number\">2</span>,</span><br><span class=\"line\">  nonEnum: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.ownKeys(obj)</span><br><span class=\"line\"><span class=\"comment\">//  [\"enum\", \"nonEnum\", Symbol(my_key)]</span></span><br></pre></td></tr></table></div></figure>\n\n<p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> size = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'size'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>[size] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add(item) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>[<span class=\"keyword\">this</span>[size]] = item;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>[size]++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> sizeOf(instance) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance[size];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> Collection();</span><br><span class=\"line\">Collection.sizeOf(x) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">x.add(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\">Collection.sizeOf(x) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(x) <span class=\"comment\">// ['0']</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(x) <span class=\"comment\">// ['0']</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertySymbols(x) <span class=\"comment\">// [Symbol(size)]</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>\n<h2 id=\"Symbol-for-，Symbol-keyFor\">Symbol.for()，Symbol.keyFor()<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-for-，Symbol-keyFor\"></a></h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>\n<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"bar\"</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">\"bar\"</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>\n<p><code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>.keyFor(s1) <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>.keyFor(s2) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>\n<p>需要注意的是，<code>Symbol.for</code>为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iframe = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">iframe.src = <span class=\"built_in\">String</span>(<span class=\"built_in\">window</span>.location);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(iframe);</span><br><span class=\"line\"></span><br><span class=\"line\">iframe.contentWindow.Symbol.for(<span class=\"string\">'foo'</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>\n<h2 id=\"实例：模块的-Singleton-模式\">实例：模块的 Singleton 模式<a href=\"2019/10/07/ES6-Docs/ES6-symbol#实例：模块的-Singleton-模式\"></a></h2><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>\n<p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>\n<p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mod.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.foo = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!global._foo) &#123;</span><br><span class=\"line\">  global._foo = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = global._foo;</span><br></pre></td></tr></table></div></figure>\n\n<p>然后，加载上面的<code>mod.js</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./mod.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.foo);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p>\n<p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global._foo = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'world'</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./mod.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.foo);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p>\n<p>为了防止这种情况出现，我们就可以使用 Symbol。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mod.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FOO_KEY = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.foo = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!global[FOO_KEY]) &#123;</span><br><span class=\"line\">  global[FOO_KEY] = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = global[FOO_KEY];</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>)] = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'world'</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./mod.js'</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mod.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FOO_KEY = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后面代码相同 ……</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p>\n<h2 id=\"内置的-Symbol-值\">内置的 Symbol 值<a href=\"2019/10/07/ES6-Docs/ES6-symbol#内置的-Symbol-值\"></a></h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>\n<h3 id=\"Symbol-hasInstance\">Symbol.hasInstance<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-hasInstance\"></a></h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.hasInstance](foo) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] <span class=\"keyword\">instanceof</span> <span class=\"keyword\">new</span> MyClass() <span class=\"comment\">// true</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>\n<p>下面是另一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Even</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> [<span class=\"built_in\">Symbol</span>.hasInstance](obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Number</span>(obj) % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Even = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.hasInstance](obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Number</span>(obj) % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">instanceof</span> Even <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">instanceof</span> Even <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">12345</span> <span class=\"keyword\">instanceof</span> Even <span class=\"comment\">// false</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"Symbol-isConcatSpreadable\">Symbol.isConcatSpreadable<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-isConcatSpreadable\"></a></h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].concat(arr1, <span class=\"string\">'e'</span>) <span class=\"comment\">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class=\"line\">arr1[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\">arr2[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].concat(arr2, <span class=\"string\">'e'</span>) <span class=\"comment\">// ['a', 'b', ['c','d'], 'e']</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>\n<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">length</span>: <span class=\"number\">2</span>, <span class=\"number\">0</span>: <span class=\"string\">'c'</span>, <span class=\"number\">1</span>: <span class=\"string\">'d'</span>&#125;;</span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].concat(obj, <span class=\"string\">'e'</span>) <span class=\"comment\">// ['a', 'b', obj, 'e']</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].concat(obj, <span class=\"string\">'e'</span>) <span class=\"comment\">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></div></figure>\n\n<p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(args) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(args);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(args) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> [Symbol.isConcatSpreadable] () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a1 = <span class=\"keyword\">new</span> A1();</span><br><span class=\"line\">a1[<span class=\"number\">0</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">a1[<span class=\"number\">1</span>] = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = <span class=\"keyword\">new</span> A2();</span><br><span class=\"line\">a2[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">a2[<span class=\"number\">1</span>] = <span class=\"number\">6</span>;</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>].concat(a1).concat(a2)</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>\n<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>\n<h3 id=\"Symbol-species\">Symbol.species<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-species\"></a></h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> MyArray(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = a.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x);</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x &gt; <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b <span class=\"keyword\">instanceof</span> MyArray <span class=\"comment\">// true</span></span><br><span class=\"line\">c <span class=\"keyword\">instanceof</span> MyArray <span class=\"comment\">// true</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>\n<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>现在，再来看前面的例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> MyArray();</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = a.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x);</span><br><span class=\"line\"></span><br><span class=\"line\">b <span class=\"keyword\">instanceof</span> MyArray <span class=\"comment\">// false</span></span><br><span class=\"line\">b <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>\n<p>再看一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> T1(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r()).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v) <span class=\"keyword\">instanceof</span> T1 <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> T2(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r()).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v) <span class=\"keyword\">instanceof</span> T2 <span class=\"comment\">// false</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>\n<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>\n<h3 id=\"Symbol-match\">Symbol.match<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-match\"></a></h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.match(regexp)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">regexp[<span class=\"built_in\">Symbol</span>.match](<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMatcher</span> </span>&#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.match](string) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>.indexOf(string);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'e'</span>.match(<span class=\"keyword\">new</span> MyMatcher()) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"Symbol-replace\">Symbol.replace<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-replace\"></a></h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.replace(searchValue, replaceValue)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">searchValue[<span class=\"built_in\">Symbol</span>.replace](<span class=\"keyword\">this</span>, replaceValue)</span><br></pre></td></tr></table></div></figure>\n\n<p>下面是一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = &#123;&#125;;</span><br><span class=\"line\">x[<span class=\"built_in\">Symbol</span>.replace] = <span class=\"function\">(<span class=\"params\">...s</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'Hello'</span>.replace(x, <span class=\"string\">'World'</span>) <span class=\"comment\">// [\"Hello\", \"World\"]</span></span><br></pre></td></tr></table></div></figure>\n\n<p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>\n<h3 id=\"Symbol-search\">Symbol.search<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-search\"></a></h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.search(regexp)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">regexp[<span class=\"built_in\">Symbol</span>.search](<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySearch</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.search](string) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> string.indexOf(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">'foobar'</span>.search(<span class=\"keyword\">new</span> MySearch(<span class=\"string\">'foo'</span>)) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"Symbol-split\">Symbol.split<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-split\"></a></h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.split(separator, limit)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">separator[<span class=\"built_in\">Symbol</span>.split](<span class=\"keyword\">this</span>, limit)</span><br></pre></td></tr></table></div></figure>\n\n<p>下面是一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySplitter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.split](string) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = string.indexOf(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> string;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">      string.substr(<span class=\"number\">0</span>, index),</span><br><span class=\"line\">      string.substr(index + <span class=\"keyword\">this</span>.value.length)</span><br><span class=\"line\">    ];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'foobar'</span>.split(<span class=\"keyword\">new</span> MySplitter(<span class=\"string\">'foo'</span>))</span><br><span class=\"line\"><span class=\"comment\">// ['', 'bar']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'foobar'</span>.split(<span class=\"keyword\">new</span> MySplitter(<span class=\"string\">'bar'</span>))</span><br><span class=\"line\"><span class=\"comment\">// ['foo', '']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'foobar'</span>.split(<span class=\"keyword\">new</span> MySplitter(<span class=\"string\">'baz'</span>))</span><br><span class=\"line\"><span class=\"comment\">// 'foobar'</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>\n<h3 id=\"Symbol-iterator\">Symbol.iterator<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-iterator\"></a></h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[...myIterable] <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></div></figure>\n\n<p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collection</span> </span>&#123;</span><br><span class=\"line\">  *[<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>[i] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>[i];</span><br><span class=\"line\">      ++i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myCollection = <span class=\"keyword\">new</span> Collection();</span><br><span class=\"line\">myCollection[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">myCollection[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> myCollection) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"Symbol-toPrimitive\">Symbol.toPrimitive<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-toPrimitive\"></a></h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>\n<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>\n<ul>\n<li>Number：该场合需要转成数值</li>\n<li>String：该场合需要转成字符串</li>\n<li>Default：该场合可以转成数值，也可以转成字符串</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (hint) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'number'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'string'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'str'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'default'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'default'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span> * obj <span class=\"comment\">// 246</span></span><br><span class=\"line\"><span class=\"number\">3</span> + obj <span class=\"comment\">// '3default'</span></span><br><span class=\"line\">obj == <span class=\"string\">'default'</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>(obj) <span class=\"comment\">// 'str'</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"Symbol-toStringTag\">Symbol.toStringTag<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-toStringTag\"></a></h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">(&#123;[<span class=\"built_in\">Symbol</span>.toStringTag]: <span class=\"string\">'Foo'</span>&#125;.toString())</span><br><span class=\"line\"><span class=\"comment\">// \"[object Foo]\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> [Symbol.toStringTag]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'xxx'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> Collection();</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(x) <span class=\"comment\">// \"[object xxx]\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>\n<ul>\n<li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li>\n<li><code>Math[Symbol.toStringTag]</code>：’Math’</li>\n<li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li>\n<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li>\n<li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li>\n<li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li>\n<li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li>\n<li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li>\n<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li>\n<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li>\n<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li>\n<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li>\n<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li>\n<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li>\n<li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li>\n<li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li>\n<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li>\n</ul>\n<h3 id=\"Symbol-unscopables\">Symbol.unscopables<a href=\"2019/10/07/ES6-Docs/ES6-symbol#Symbol-unscopables\"></a></h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype[<span class=\"built_in\">Symbol</span>.unscopables]</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   copyWithin: true,</span></span><br><span class=\"line\"><span class=\"comment\">//   entries: true,</span></span><br><span class=\"line\"><span class=\"comment\">//   fill: true,</span></span><br><span class=\"line\"><span class=\"comment\">//   find: true,</span></span><br><span class=\"line\"><span class=\"comment\">//   findIndex: true,</span></span><br><span class=\"line\"><span class=\"comment\">//   includes: true,</span></span><br><span class=\"line\"><span class=\"comment\">//   keys: true</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">Array</span>.prototype[<span class=\"built_in\">Symbol</span>.unscopables])</span><br><span class=\"line\"><span class=\"comment\">// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有 unscopables 时</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  foo() &#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> (MyClass.prototype) &#123;</span><br><span class=\"line\">  foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有 unscopables 时</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  foo() &#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> [Symbol.unscopables]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">foo</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> (MyClass.prototype) &#123;</span><br><span class=\"line\">  foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>\n","prev":{"title":"ES6-simd","link":"2019/10/07/ES6-Docs/ES6-simd"},"next":{"title":"ES6-function","link":"2019/10/07/ES6-Docs/ES6-function"},"plink":"https://guo213.github.io/2019/10/07/ES6-Docs/ES6-symbol/","toc":[{"title":"Symbol","id":"Symbol","index":"1","children":[{"title":"概述","id":"概述","index":"1.1"},{"title":"Symbol.prototype.description","id":"Symbol-prototype-description","index":"1.2"},{"title":"作为属性名的 Symbol","id":"作为属性名的-Symbol","index":"1.3"},{"title":"实例：消除魔术字符串","id":"实例：消除魔术字符串","index":"1.4"},{"title":"属性名的遍历","id":"属性名的遍历","index":"1.5"},{"title":"Symbol.for()，Symbol.keyFor()","id":"Symbol-for-，Symbol-keyFor","index":"1.6"},{"title":"实例：模块的 Singleton 模式","id":"实例：模块的-Singleton-模式","index":"1.7"},{"title":"内置的 Symbol 值","id":"内置的-Symbol-值","index":"1.8","children":[{"title":"Symbol.hasInstance","id":"Symbol-hasInstance","index":"1.8.1"},{"title":"Symbol.isConcatSpreadable","id":"Symbol-isConcatSpreadable","index":"1.8.2"},{"title":"Symbol.species","id":"Symbol-species","index":"1.8.3"},{"title":"Symbol.match","id":"Symbol-match","index":"1.8.4"},{"title":"Symbol.replace","id":"Symbol-replace","index":"1.8.5"},{"title":"Symbol.search","id":"Symbol-search","index":"1.8.6"},{"title":"Symbol.split","id":"Symbol-split","index":"1.8.7"},{"title":"Symbol.iterator","id":"Symbol-iterator","index":"1.8.8"},{"title":"Symbol.toPrimitive","id":"Symbol-toPrimitive","index":"1.8.9"},{"title":"Symbol.toStringTag","id":"Symbol-toStringTag","index":"1.8.10"},{"title":"Symbol.unscopables","id":"Symbol-unscopables","index":"1.8.11"}]}]}]}