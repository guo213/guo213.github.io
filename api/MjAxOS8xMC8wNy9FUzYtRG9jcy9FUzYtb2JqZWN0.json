{"title":"ES6-object","date":"2019-10-06T16:00:00.000Z","link":"2019/10/07/ES6-Docs/ES6-object","tags":["ES6","ES6-object"],"categories":["ES6"],"updated":"2019-10-07T09:03:34.000Z","content":"<h1 id=\"对象的扩展\">对象的扩展<a href=\"2019/10/07/ES6-Docs/ES6-object#对象的扩展\"></a></h1><p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\n<h2 id=\"属性的简洁表示法\">属性的简洁表示法<a href=\"2019/10/07/ES6-Docs/ES6-object#属性的简洁表示法\"></a></h2><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123;foo&#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// &#123;foo: \"bar\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123;<span class=\"attr\">foo</span>: foo&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，变量<code>foo</code>直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;x, y&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>除了属性简写，方法也可以简写。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  method() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>下面是一个实际的例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> birth = <span class=\"string\">'2000/01/01'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Person = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  name: <span class=\"string\">'张三'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//等同于birth: birth</span></span><br><span class=\"line\">  birth,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 等同于hello: function ()...</span></span><br><span class=\"line\">  hello() &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'我的名字是'</span>, <span class=\"keyword\">this</span>.name); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>这种写法用于函数的返回值，将会非常方便。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPoint</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> y = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;x, y&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getPoint()</span><br><span class=\"line\"><span class=\"comment\">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ms = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getItem</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> ms ? ms[key] : <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setItem</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  ms[key] = value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clear</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ms = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; getItem, setItem, clear &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  getItem: getItem,</span><br><span class=\"line\">  setItem: setItem,</span><br><span class=\"line\">  clear: clear</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cart = &#123;</span><br><span class=\"line\">  _wheels: <span class=\"number\">4</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> wheels () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._wheels;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> wheels (value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &lt; <span class=\"keyword\">this</span>._wheels) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'数值太小了！'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._wheels = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>简洁写法在打印对象时也很有用。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'test'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">  bar: <span class=\"string\">'baz'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user, foo)</span><br><span class=\"line\"><span class=\"comment\">// &#123;name: \"test\"&#125; &#123;bar: \"baz\"&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;user, foo&#125;)</span><br><span class=\"line\"><span class=\"comment\">// &#123;user: &#123;name: \"test\"&#125;, foo: &#123;bar: \"baz\"&#125;&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>console.log</code>直接输出<code>user</code>和<code>foo</code>两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰了。</p>\n<h2 id=\"属性名表达式\">属性名表达式<a href=\"2019/10/07/ES6-Docs/ES6-object#属性名表达式\"></a></h2><p>JavaScript 定义对象的属性，有两种方法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\">obj.foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\">obj[<span class=\"string\">'a'</span> + <span class=\"string\">'bc'</span>] = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>\n<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  abc: <span class=\"number\">123</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> propKey = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [propKey]: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  [<span class=\"string\">'a'</span> + <span class=\"string\">'bc'</span>]: <span class=\"number\">123</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>下面是另一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> lastWord = <span class=\"string\">'last word'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">  <span class=\"string\">'first word'</span>: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">  [lastWord]: <span class=\"string\">'world'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a[<span class=\"string\">'first word'</span>] <span class=\"comment\">// \"hello\"</span></span><br><span class=\"line\">a[lastWord] <span class=\"comment\">// \"world\"</span></span><br><span class=\"line\">a[<span class=\"string\">'last word'</span>] <span class=\"comment\">// \"world\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>表达式还可以用于定义方法名。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"string\">'h'</span> + <span class=\"string\">'ello'</span>]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hi'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.hello() <span class=\"comment\">// hi</span></span><br></pre></td></tr></table></div></figure>\n\n<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; [foo] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; [foo]: <span class=\"string\">'abc'</span>&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> keyA = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> keyB = &#123;<span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</span><br><span class=\"line\">  [keyA]: <span class=\"string\">'valueA'</span>,</span><br><span class=\"line\">  [keyB]: <span class=\"string\">'valueB'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject <span class=\"comment\">// Object &#123;[object Object]: \"valueB\"&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>\n<h2 id=\"方法的-name-属性\">方法的 name 属性<a href=\"2019/10/07/ES6-Docs/ES6-object#方法的-name-属性\"></a></h2><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  sayName() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello!'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.sayName.name   <span class=\"comment\">// \"sayName\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>\n<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> foo() &#123;&#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> foo(x) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo.name</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Cannot read property 'name' of undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">descriptor.get.name <span class=\"comment\">// \"get foo\"</span></span><br><span class=\"line\">descriptor.set.name <span class=\"comment\">// \"set foo\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>()).name <span class=\"comment\">// \"anonymous\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">doSomething.bind().name <span class=\"comment\">// \"bound doSomething\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'description'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> key2 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [key1]() &#123;&#125;,</span><br><span class=\"line\">  [key2]() &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj[key1].name <span class=\"comment\">// \"[description]\"</span></span><br><span class=\"line\">obj[key2].name <span class=\"comment\">// \"\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>\n<h2 id=\"属性的可枚举性和遍历\">属性的可枚举性和遍历<a href=\"2019/10/07/ES6-Docs/ES6-object#属性的可枚举性和遍历\"></a></h2><h3 id=\"可枚举性\">可枚举性<a href=\"2019/10/07/ES6-Docs/ES6-object#可枚举性\"></a></h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    value: 123,</span></span><br><span class=\"line\"><span class=\"comment\">//    writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    configurable: true</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>\n<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>\n<ul>\n<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>\n<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>\n<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>\n<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>\n</ul>\n<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(<span class=\"built_in\">Object</span>.prototype, <span class=\"string\">'toString'</span>).enumerable</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor([], <span class=\"string\">'length'</span>).enumerable</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>\n<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(<span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;foo() &#123;&#125;&#125;.prototype, <span class=\"string\">'foo'</span>).enumerable</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></div></figure>\n\n<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>\n<h3 id=\"属性的遍历\">属性的遍历<a href=\"2019/10/07/ES6-Docs/ES6-object#属性的遍历\"></a></h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>\n<p><strong>（1）for…in</strong></p>\n<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>\n<p><strong>（2）Object.keys(obj)</strong></p>\n<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>\n<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>\n<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>\n<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>\n<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>\n<p><strong>（5）Reflect.ownKeys(obj)</strong></p>\n<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>\n<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有数值键，按照数值升序排列。</li>\n<li>其次遍历所有字符串键，按照加入时间升序排列。</li>\n<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Reflect</span>.ownKeys(&#123; [<span class=\"built_in\">Symbol</span>()]:<span class=\"number\">0</span>, <span class=\"attr\">b</span>:<span class=\"number\">0</span>, <span class=\"number\">10</span>:<span class=\"number\">0</span>, <span class=\"number\">2</span>:<span class=\"number\">0</span>, <span class=\"attr\">a</span>:<span class=\"number\">0</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>\n<h2 id=\"super-关键字\">super 关键字<a href=\"2019/10/07/ES6-Docs/ES6-object#super-关键字\"></a></h2><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proto = &#123;</span><br><span class=\"line\">  foo: <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"string\">'world'</span>,</span><br><span class=\"line\">  find() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.foo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br><span class=\"line\">obj.find() <span class=\"comment\">// \"hello\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>\n<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"keyword\">super</span>.foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">super</span>.foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.foo</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>\n<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proto = &#123;</span><br><span class=\"line\">  x: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">  foo() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  x: <span class=\"string\">'world'</span>,</span><br><span class=\"line\">  foo() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.foo();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// \"world\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>\n<h2 id=\"对象的扩展运算符\">对象的扩展运算符<a href=\"2019/10/07/ES6-Docs/ES6-object#对象的扩展运算符\"></a></h2><p>《数组的扩展》一章中，已经介绍过扩展运算符（<code>...</code>）。ES2018 将这个运算符<a href=\"https://github.com/sebmarkbage/ecmascript-rest-spread\" target=\"_blank\" rel=\"noopener\">引入</a>了对象。</p>\n<h3 id=\"解构赋值\">解构赋值<a href=\"2019/10/07/ES6-Docs/ES6-object#解构赋值\"></a></h3><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 2</span></span><br><span class=\"line\">z <span class=\"comment\">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>\n<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; ...z &#125; = <span class=\"literal\">null</span>; <span class=\"comment\">// 运行时错误</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; ...z &#125; = <span class=\"literal\">undefined</span>; <span class=\"comment\">// 运行时错误</span></span><br></pre></td></tr></table></div></figure>\n\n<p>解构赋值必须是最后一个参数，否则会报错。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; ...x, y, z &#125; = someObject; <span class=\"comment\">// 句法错误</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; x, ...y, ...z &#125; = someObject; <span class=\"comment\">// 句法错误</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>\n<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; ...x &#125; = obj;</span><br><span class=\"line\">obj.a.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">x.a.b <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>\n<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o1 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o2 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">o2.__proto__ = o1;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; ...o3 &#125; = o2;</span><br><span class=\"line\">o3 <span class=\"comment\">// &#123; b: 2 &#125;</span></span><br><span class=\"line\">o3.a <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p>\n<p>下面是另一个例子。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> o = <span class=\"built_in\">Object</span>.create(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span> &#125;);</span><br><span class=\"line\">o.z = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; x, ...newObj &#125; = o;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; y, z &#125; = newObj;</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// undefined</span></span><br><span class=\"line\">z <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: ... must be followed by an identifier in declaration contexts</span></span><br></pre></td></tr></table></div></figure>\n\n<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseFunction</span>(<span class=\"params\">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapperFunction</span>(<span class=\"params\">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用 x 和 y 参数进行操作</span></span><br><span class=\"line\">  <span class=\"comment\">// 其余参数传给原始函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseFunction(restConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>\n<h3 id=\"扩展运算符\">扩展运算符<a href=\"2019/10/07/ES6-Docs/ES6-object#扩展运算符\"></a></h3><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = &#123; ...z &#125;;</span><br><span class=\"line\">n <span class=\"comment\">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123; ...[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>] &#125;;</span><br><span class=\"line\">foo</span><br><span class=\"line\"><span class=\"comment\">// &#123;0: \"a\", 1: \"b\", 2: \"c\"&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;...&#123;&#125;, <span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等同于 &#123;...Object(1)&#125;</span></span><br><span class=\"line\">&#123;..<span class=\"number\">.1</span>&#125; <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number{1}</code>。由于该对象没有自身属性，所以返回一个空对象。</p>\n<p>下面的例子都是类似的道理。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等同于 &#123;...Object(true)&#125;</span></span><br><span class=\"line\">&#123;...true&#125; <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于 &#123;...Object(undefined)&#125;</span></span><br><span class=\"line\">&#123;...undefined&#125; <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于 &#123;...Object(null)&#125;</span></span><br><span class=\"line\">&#123;...null&#125; <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;...<span class=\"string\">'hello'</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> aClone = &#123; ...a &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aClone = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone1 = &#123;</span><br><span class=\"line\">  __proto__: <span class=\"built_in\">Object</span>.getPrototypeOf(obj),</span><br><span class=\"line\">  ...obj</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone2 = <span class=\"built_in\">Object</span>.assign(</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)),</span><br><span class=\"line\">  obj</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone3 = <span class=\"built_in\">Object</span>.create(</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.getPrototypeOf(obj),</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>\n<p>扩展运算符可以用于合并两个对象。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ab = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></div></figure>\n\n<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> aWithOverrides = &#123; ...a, <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>, y = <span class=\"number\">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aWithOverrides = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, a, &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span> &#125;);</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>\n<p>这用来修改现有对象部分的属性就很方便了。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newVersion = &#123;</span><br><span class=\"line\">  ...previousVersion,</span><br><span class=\"line\">  name: <span class=\"string\">'New Name'</span> <span class=\"comment\">// Override the name property</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p>\n<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> aWithDefaults = &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, ...a &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aWithDefaults = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span> &#125;, a);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aWithDefaults = <span class=\"built_in\">Object</span>.assign(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span> &#125;, a);</span><br></pre></td></tr></table></div></figure>\n\n<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  ...(x &gt; <span class=\"number\">1</span> ? &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125; : &#123;&#125;),</span><br><span class=\"line\">  b: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aWithXGetter = &#123;</span><br><span class=\"line\">  ...a,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> x() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'not throw yet'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 会抛出错误，因为 x 属性被执行了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> runtimeError = &#123;</span><br><span class=\"line\">  ...a,</span><br><span class=\"line\">  ...&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> x() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'throw now'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n","prev":{"title":"ES6-object-methods","link":"2019/10/07/ES6-Docs/ES6-object-methods"},"next":{"title":"ES6-regex","link":"2019/10/07/ES6-Docs/ES6-regex"},"plink":"https://guo213.github.io/2019/10/07/ES6-Docs/ES6-object/","toc":[{"title":"对象的扩展","id":"对象的扩展","index":"1","children":[{"title":"属性的简洁表示法","id":"属性的简洁表示法","index":"1.1"},{"title":"属性名表达式","id":"属性名表达式","index":"1.2"},{"title":"方法的 name 属性","id":"方法的-name-属性","index":"1.3"},{"title":"属性的可枚举性和遍历","id":"属性的可枚举性和遍历","index":"1.4","children":[{"title":"可枚举性","id":"可枚举性","index":"1.4.1"},{"title":"属性的遍历","id":"属性的遍历","index":"1.4.2"}]},{"title":"super 关键字","id":"super-关键字","index":"1.5"},{"title":"对象的扩展运算符","id":"对象的扩展运算符","index":"1.6","children":[{"title":"解构赋值","id":"解构赋值","index":"1.6.1"},{"title":"扩展运算符","id":"扩展运算符","index":"1.6.2"}]}]}]}